<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module ldclient_context</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module ldclient_context</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Context data type  
When constructing a context by hand, not using new/1, new/2 or new_from_map,  
then you must include a kind attribute.


<h2><a name="description">Description</a></h2><p>Context data type  
When constructing a context by hand, not using new/1, new/2 or new_from_map,  
then you must include a kind attribute.</p>
 
  The kind attribute is used to differentiate between a map representing
  a ldclient_user and one representing a ldclient_context.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-attribute_key">attribute_key()</a></h3>
<p><tt>attribute_key() = binary() | key | kind | anonymous | private_attributes | name</tt></p>
<p>  Attribute keys must be binary() strings. They should not be empty, and they must not be <code>&lt;&lt;"_meta"&gt;&gt;</code>.</p>

<h3 class="typedecl"><a name="type-attribute_map">attribute_map()</a></h3>
<p><tt>attribute_map() = #{<a href="#type-attribute_key">attribute_key()</a> =&gt; <a href="#type-attribute_value">attribute_value()</a>}</tt></p>


<h3 class="typedecl"><a name="type-attribute_value">attribute_value()</a></h3>
<p><tt>attribute_value() = binary() | integer() | float() | boolean() | <a href="#type-attribute_map">attribute_map()</a> | [<a href="#type-attribute_value">attribute_value()</a>]</tt></p>
<p>  Attribute values should all be data types which are compatible with JSON and nested JSON collections.
  The leaf nodes of these values are what are ultimately used when evaluating flags which are dependent on attributes.</p>

<h3 class="typedecl"><a name="type-context">context()</a></h3>
<p><tt>context() = <a href="#type-single_context">single_context()</a> | <a href="#type-multi_context">multi_context()</a></tt></p>


<h3 class="typedecl"><a name="type-context_part">context_part()</a></h3>
<p><tt>context_part() = #{key := <a href="#type-key">key()</a>, name := binary(), private_attributes =&gt; [binary()], anonymous =&gt; boolean(), attributes =&gt; <a href="#type-attribute_map">attribute_map()</a>}</tt></p>
<p>  The content of a multi context. Should be the same as a <a docgen-rel="seemfa" docgen-href="#single_context/0" href="#single_context-0"><code>single_context/0</code></a> aside from missing 'kind'.
  A multi context is keyed by the 'kind'.</p>

<h3 class="typedecl"><a name="type-key">key()</a></h3>
<p><tt>key() = binary()</tt></p>
<p>  Keys may be any non-empty binary() string. <code>&lt;&lt;&gt;&gt;</code> and <code>&lt;&lt;""&gt;&gt;</code> are not valid.
  Keys must be binaries, and should match those in LaunchDarkly exactly.
  No casing conversions will be applied <code>&lt;&lt;"my_attribute"&gt;&gt;</code> will only match <code>&lt;&lt;"my_attribute"&gt;&gt;</code>, it would not match
  <code>&lt;&lt;"myAttribute"&gt;&gt;</code>.</p>

<h3 class="typedecl"><a name="type-kind_value">kind_value()</a></h3>
<p><tt>kind_value() = binary()</tt></p>
<p>  May only contain ASCII letters, numbers, ., _ or -.
  <code>&lt;&lt;"my_kind.0-1"&gt;&gt;</code> would be valid.
  <code>&lt;&lt;"my:kind.{0}"&gt;&gt;</code> would not, it contains ':' and '{}' which are not allowed.
  Kinds should be binaries, and should match the context kinds exactly.
  No casing conversions will be applied <code>&lt;&lt;"my_kind"&gt;&gt;</code> will only match <code>&lt;&lt;"my_kind"&gt;&gt;</code>, it would not match
  <code>&lt;&lt;"myKind"&gt;&gt;</code>.</p>

<h3 class="typedecl"><a name="type-multi_context">multi_context()</a></h3>
<p><tt>multi_context() = #{kind := <a href="#type-kind_value">kind_value()</a>, <a href="#type-kind_value">kind_value()</a> := <a href="#type-context_part">context_part()</a>}</tt></p>
<p><p>  A context which represents multiple kinds. Each kind having its own key and attributes.</p>
 
  <p>A multi-context must contain <code>kind =&gt; &lt;&lt;"multi"&gt;&gt;</code> at the root.</p>
 
  <pre>  MyMultiContext = #{
    %% Multi-contexts must be of kind &lt;&lt;"multi"&gt;&gt;.
    kind =&gt; &lt;&lt;"multi"&gt;&gt;,
    %% The context is namespaced by its kind. This is an 'org' kind context.
    &lt;&lt;"org"&gt;&gt; =&gt; #{
      // Each component context has its own key and attributes.
      key =&gt; &lt;&lt;"my-org-key"&gt;&gt;,
      attributes =&gt; #{
          &lt;&lt;"someAttribute"&gt;&gt; =&gt; &lt;&lt;"my-attribute-value"&gt;&gt;,
      }
    },
    &lt;&lt;"user"&gt;&gt; =&gt; #{
      key =&gt; &lt;&lt;"my-user-key"&gt;&gt;,
      %% Each component context has its own meta attributes. This will only apply the this
      %% 'user' context.
      private_attributes =&gt; [&lt;&lt;"firstName"&gt;&gt;]
      attributes =&gt; #{
          &lt;&lt;"firstName"&gt;&gt; =&gt; &lt;&lt;"Bob"&gt;&gt;,
          &lt;&lt;"lastName"&gt;&gt; =&gt; &lt;&lt;"Bobberson"&gt;&gt;,
      }
    }
  }.</pre>
 
  The above multi-context contains both an 'org' and a 'user'. Each with their own key,
  attributes, and _meta attributes.</p>

<h3 class="typedecl"><a name="type-single_context">single_context()</a></h3>
<p><tt>single_context() = #{key := <a href="#type-key">key()</a>, name =&gt; binary(), kind := <a href="#type-kind_value">kind_value()</a>, private_attributes =&gt; [binary()], anonymous =&gt; boolean(), attributes =&gt; <a href="#type-attribute_map">attribute_map()</a>}</tt></p>
<p><p>  A context which represents a single kind.</p>
 
  <p>For a single kind context the 'kind' may not be <code>&lt;&lt;"multi"&gt;&gt;</code>.</p>
 
  <pre>  MyOrgContext = #{
      kind =&gt; &lt;&lt;"org"&gt;&gt;,
      key =&gt; &lt;&lt;"my-org-key"&gt;&gt;,
      attributes =&gt; #{
        &lt;&lt;"someAttribute"&gt;&gt; =&gt; &lt;&lt;"my-attribute-value"&gt;&gt;
      }
  }.</pre>
 
  The above context would be a single kind context representing an organization. It has a key
  for that organization, and a single attribute 'someAttribute'.</p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#get-3">get/3</a></td><td>Get an attribute value from the specified context kind by the specified attribute reference.</td></tr>
<tr><td valign="top"><a href="#get_canonical_key-1">get_canonical_key/1</a></td><td>A string that describes the entire Context based on Kind and Key values.</td></tr>
<tr><td valign="top"><a href="#get_key-2">get_key/2</a></td><td>Get the key for the specified context kind.</td></tr>
<tr><td valign="top"><a href="#get_kinds-1">get_kinds/1</a></td><td>Get all the kinds in the specified context.</td></tr>
<tr><td valign="top"><a href="#is_valid-2">is_valid/2</a></td><td>Verify a context is valid.</td></tr>
<tr><td valign="top"><a href="#new-1">new/1</a></td><td>Create a new 'user' context with the specified key.</td></tr>
<tr><td valign="top"><a href="#new-2">new/2</a></td><td>Create a new context with the specified key and kind.</td></tr>
<tr><td valign="top"><a href="#new_from_json-1">new_from_json/1</a></td><td>Parse a map created from the JSON representation of a context into an <a docgen-rel="seetype" docgen-href="ldclient_context#context/0" href="ldclient_context.html#type-context"><code>ldclient_context:context()</code></a>.</td></tr>
<tr><td valign="top"><a href="#new_from_map-1">new_from_map/1</a></td><td>Create a context from a map.</td></tr>
<tr><td valign="top"><a href="#new_from_user-1">new_from_user/1</a></td><td>Create a context from an <a docgen-rel="seetype" docgen-href="ldclient_user#user/0" href="ldclient_user.html#type-user"><code>ldclient_user:user()</code></a>.</td></tr>
<tr><td valign="top"><a href="#new_multi_from-1">new_multi_from/1</a></td><td>Create a multi context from several single kind contexts and/or multi contexts.</td></tr>
<tr><td valign="top"><a href="#set-3">set/3</a></td><td>Set an attribute value with the specified key in a single kind context.</td></tr>
<tr><td valign="top"><a href="#set-4">set/4</a></td><td>Set an attribute value in the specified context kind with the specified key.</td></tr>
<tr><td valign="top"><a href="#set_private_attributes-2">set_private_attributes/2</a></td><td>Set private attributes for a single kind context.</td></tr>
<tr><td valign="top"><a href="#set_private_attributes-3">set_private_attributes/3</a></td><td>Set private attributes for the specified context kind.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="get-3">get/3</a></h3>
<div class="spec">
<p><tt>get(ContextKind::<a href="#type-kind_value">kind_value()</a>, AttributeReference::<a href="http://www.erlang.org/edoc/doc/ldclient/doc/ldclient_attribute_reference.html#type-attribute_reference">ldclient_attribute_reference:attribute_reference()</a> | binary(), Context::<a href="#type-context">context()</a>) -&gt; <a href="#type-attribute_value">attribute_value()</a> | null</tt><br></p>
<p> </p>
</div><p><p>Get an attribute value from the specified context kind by the specified attribute reference</p>
 
  <p>If the context is a single kind context, and the ContextKind matches the context's kind, and the context contains  
the specified attribute, then that value will be provided.</p>
 
  <p>If the context is a multi-context, and it contains the specified context kind, and that context kind contains  
the specified attribute, then that value will be provided.</p>
 
  If the attribute value does not exist, then the null atom will be returned.</p>

<h3 class="function"><a name="get_canonical_key-1">get_canonical_key/1</a></h3>
<div class="spec">
<p><tt>get_canonical_key(Context::<a href="#type-context">context()</a>) -&gt; binary()</tt><br></p>
<p> </p>
</div><p><p>A string that describes the entire Context based on Kind and Key values.</p>
 
  This value is used whenever LaunchDarkly needs a string identifier based on all of the Kind and
  Key values in the context; the SDK may use this for caching previously seen contexts, for instance.</p>

<h3 class="function"><a name="get_key-2">get_key/2</a></h3>
<div class="spec">
<p><tt>get_key(ContextKind::<a href="#type-kind_value">kind_value()</a>, Context::<a href="#type-context">context()</a>) -&gt; binary() | null</tt><br></p>
<p> </p>
</div><p><p>Get the key for the specified context kind.</p>
 
  <p>If the context is of a single kind, and it does not match the specified context kind, then null will be returned.</p>
 
  If the context is a multi-context, and does not contain the specified kind, then null will be returned.</p>

<h3 class="function"><a name="get_kinds-1">get_kinds/1</a></h3>
<div class="spec">
<p><tt>get_kinds(Context::<a href="#type-context">context()</a>) -&gt; [binary()]</tt><br></p>
<p> </p>
</div><p><p>Get all the kinds in the specified context. Can be a single or multi context.</p>
 
  The kind in the context may be an atom or a binary, but this will always return them as binaries for use
  in comparison against strings from LaunchDarkly.</p>

<h3 class="function"><a name="is_valid-2">is_valid/2</a></h3>
<div class="spec">
<p><tt>is_valid(Context::<a href="#type-context">context()</a>, AllowEmptyKey::boolean()) -&gt; boolean()</tt><br></p>
<p> </p>
</div><p><p>Verify a context is valid.</p>
 
  <p>This will ensure that the context, or contexts of a multi context, have:</p>
 
  <p>1.) Valid keys. Key must exist, must be a binary, and cannot be empty.
      An exception is made for contexts created from an <a docgen-rel="seetype" docgen-href="ldclient_user#user/0" href="ldclient_user.html#type-user"><code>ldclient_user:user()</code></a>.</p>
 
  <p>2.) Valid kind. Kind must exist, must be a binary, and must be composed of ASCII letters, numbers, as well as
      '-', '.', and '_'. A context created from a <a docgen-rel="seetype" docgen-href="ldclient_user#user/0" href="ldclient_user.html#type-user"><code>ldclient_user:user()</code></a> will have a <code>&lt;&lt;"user"&gt;&gt;</code> kind.</p>
 
  <p>3.) All parts of a multi context meet #1 and #2.</p>
 
  <p>Other aspects of the context may be invalid, and evaluation will proceed, but those invalid  
parts will not impact the evaluation. For example an attribute with an atom() key will not successfully targeted  
by rules. Some of these issues can be avoided by using the new_from_map function which will convert keys.</p>
 
  Evaluations which are done against an invalid context will return default values with a reason
  of user_not_specified.</p>

<h3 class="function"><a name="new-1">new/1</a></h3>
<div class="spec">
<p><tt>new(Key::binary()) -&gt; <a href="#type-single_context">single_context()</a></tt><br></p>
<p> </p>
</div><p>Create a new 'user' context with the specified key.
 </p>

<h3 class="function"><a name="new-2">new/2</a></h3>
<div class="spec">
<p><tt>new(Key::binary(), Kind::<a href="#type-kind_value">kind_value()</a>) -&gt; <a href="#type-single_context">single_context()</a></tt><br></p>
<p> </p>
</div><p>Create a new context with the specified key and kind.
 </p>

<h3 class="function"><a name="new_from_json-1">new_from_json/1</a></h3>
<div class="spec">
<p><tt>new_from_json(JsonMap::map()) -&gt; <a href="#type-context">context()</a> | undefined</tt><br></p>
<p> </p>
</div><p><p>Parse a map created from the JSON representation of a context into an <a docgen-rel="seetype" docgen-href="ldclient_context#context/0" href="ldclient_context.html#type-context"><code>ldclient_context:context()</code></a>.</p>
 
  If the map cannot be parsed into a context, then <code>undefined</code> will be returned.</p>

<h3 class="function"><a name="new_from_map-1">new_from_map/1</a></h3>
<div class="spec">
<p><tt>new_from_map(MapContext::map()) -&gt; Context::<a href="#type-context">context()</a></tt><br></p>
<p> </p>
</div><p><p>Create a context from a map.</p>
 
  <p>Using this method will help to ensure that all your context keys and values are of supported types. For instance  
converting all atom() keys into binary() (both for attribute keys and kinds). This can be useful for contexts  
from a serialized source.</p>
 
  <p>If the map contains a 'kind' attribute, then the resulting context will be of that kind.
  If the map contains a 'kind' attribute, with the value of <code>&lt;&lt;"multi"&gt;&gt;</code>, then a multi context will be created,  
and each top level field in the map will be a component of that context.</p>
 
  <p>If the input map contains invalid data, such as bad kinds, then the context will still be created.  
If the context contains invalid data, then evaluations will return default values with a reason of  
'user_not_specified'.</p>
 
  The same key should not be provided in the map as both an atom and a binary. For instance:
  <pre>  #{key =&gt; &lt;&lt;"the-key"&gt;&gt;, &lt;&lt;"key"&gt;&gt; =&gt; &lt;&lt;"the-key"&gt;&gt;}</pre>
 
  Create a context without a kind specified:
  <pre>  ldclient_context:new_from_map(#{
      key =&gt; &lt;&lt;"my-key"&gt;&gt;,
      attributes =&gt; #{
          nested =&gt; #{
              deeper =&gt; #{
                  value =&gt; &lt;&lt;"my-value"&gt;&gt;
              }
          }
      }
  }).
  Produces the context
  #{
      key := &lt;&lt;"my-key"&gt;&gt;,
      kind := &lt;&lt;"user"&gt;&gt;,
      attributes := #{
          &lt;&lt;"nested"&gt;&gt; := #{
              &lt;&lt;"deeper"&gt;&gt; := #{
                  &lt;&lt;"value"&gt;&gt; := &lt;&lt;"my-value"&gt;&gt;
              }
          }
      }
  }.
  No kind was included, so it was defaulted to a &lt;&lt;"user"&gt;&gt; kind.
  Notice that all the keys, and nested keys, within attributes have been converted to binaries.</pre>
 
  Creating a context with a specified kind.
  <pre>     ldclient_context:new_from_map(#{&lt;&lt;"key"&gt;&gt; =&gt; &lt;&lt;"my-key"&gt;&gt;, &lt;&lt;"kind"&gt;&gt; =&gt; &lt;&lt;"the-kind"&gt;&gt;}).
  Produces the context
  {key := &lt;&lt;"my-key"&gt;&gt;, kind := &lt;&lt;"the-kind"&gt;&gt;}.
  Notice here how the built-in keys have been corrected to atoms.</pre>
 
  <pre>  ldclient_context:new_from_map(#{
      kind =&gt; &lt;&lt;"multi"&gt;&gt;,
      &lt;&lt;"meal"&gt;&gt; =&gt; #{
          key =&gt; &lt;&lt;"user-key"&gt;&gt;,
          &lt;&lt;"name"&gt;&gt; =&gt; &lt;&lt;"the-name"&gt;&gt;, %% Key that will become an atom.
          attributes =&gt; #{
              potato =&gt; #{ %% Key that will become a binary.
                  &lt;&lt;"bacon"&gt;&gt; =&gt; true,
                  &lt;&lt;"cheese"&gt;&gt; =&gt; true
              }
          }
      },
      &lt;&lt;"location"&gt;&gt; =&gt; #{
          key =&gt; &lt;&lt;"location-key"&gt;&gt;
      }
  }).
  Produces the context
  #{
     kind := &lt;&lt;"multi"&gt;&gt;,
     &lt;&lt;"meal"&gt;&gt; := #{
         key := &lt;&lt;"user-key"&gt;&gt;,
         name := &lt;&lt;"the-name"&gt;&gt;,
         attributes := #{
             &lt;&lt;"potato"&gt;&gt; := #{
                 &lt;&lt;"bacon"&gt;&gt; := true,
                 &lt;&lt;"cheese"&gt;&gt; := true
             }
         }
     },
     &lt;&lt;"location"&gt;&gt; := #{
         key := &lt;&lt;"location-key"&gt;&gt;
     }
  }</pre></p>

<h3 class="function"><a name="new_from_user-1">new_from_user/1</a></h3>
<div class="spec">
<p><tt>new_from_user(User::<a href="http://www.erlang.org/edoc/doc/ldclient/doc/ldclient_user.html#type-user">ldclient_user:user()</a>) -&gt; <a href="#type-context">context()</a></tt><br></p>
<p> </p>
</div><p><p>Create a context from an <a docgen-rel="seetype" docgen-href="ldclient_user#user/0" href="ldclient_user.html#type-user"><code>ldclient_user:user()</code></a>.</p>
 
  <p>This function is primarily intended for use by the SDK. It will be used when calling variation methods with
  <a docgen-rel="seetype" docgen-href="ldclient_user#user/0" href="ldclient_user.html#type-user"><code>ldclient_user:user()</code></a>. An <a docgen-rel="seetype" docgen-href="ldclient_user#user/0" href="ldclient_user.html#type-user"><code>ldclient_user:user()</code></a> is detected by the lack of kind.</p>
 
  <p>Creating contexts directly, using <a docgen-rel="seemfa" docgen-href="ldclient_context#new/1" href="ldclient_context.html#new-1"><code>ldclient_context:new/1</code></a>, <a docgen-rel="seemfa" docgen-href="ldclient_context#new/2" href="ldclient_context.html#new-2"><code>ldclient_context:new/2</code></a>,
  <a docgen-rel="seemfa" docgen-href="ldclient_context#new_from_map/1" href="ldclient_context.html#new_from_map-1"><code>ldclient_context:new_from_map/1</code></a>, or creating <a docgen-rel="seetype" docgen-href="#context/0" href="#type-context"><code>context()</code></a>, will avoid this conversion.</p>
 
  The user needs to be a valid <a docgen-rel="seetype" docgen-href="ldclient_user#user/0" href="ldclient_user.html#type-user"><code>ldclient_user:user()</code></a>. A map can be converted to a user using
  <a docgen-rel="seemfa" docgen-href="ldclient_user#new_from_map/1" href="ldclient_user.html#new_from_map-1"><code>ldclient_user:new_from_map/1</code></a>. If the user does not have at least a key, then an empty map
  is returned and it will not validate. An invalid context will result in default values from variation methods.</p>

<h3 class="function"><a name="new_multi_from-1">new_multi_from/1</a></h3>
<div class="spec">
<p><tt>new_multi_from(Contexts::[<a href="#type-context">context()</a>]) -&gt; <a href="#type-multi_context">multi_context()</a> | <a href="#type-single_context">single_context()</a></tt><br></p>
<p> </p>
</div><p><p>Create a multi context from several single kind contexts and/or multi contexts.</p>
 
  <pre>  MyMultiContext = ldclient_context:new_multi_from([
      ldclient_context:new(&lt;&lt;"user-key"&gt;&gt;), %% This defaults to a &lt;&lt;"user"&gt;&gt; kind.
      ldclient_context:new(&lt;&lt;"org-key"&gt;&gt;, &lt;&lt;"org"&gt;&gt;)]).</pre>
 
  Multi contexts in the input list will be flattened, with each of their component contexts being added individually:
  <pre>  MultiContext1 = ldclient_context:new_multi_from([
      ldclient_context:new(&lt;&lt;"user-key"&gt;&gt;),
      ldclient_context:new(&lt;&lt;"org-key"&gt;&gt;, &lt;&lt;"org"&gt;&gt;)]),
  MultiContext2 = ldclient_context:new_multi_from([
      MultiContext1,
      ldclient_context:new(&lt;&lt;"device-key"&gt;&gt;, &lt;&lt;"device"&gt;&gt;)]).
  %% MultiContext2 contains user, org, and device contexts.</pre>
 
  <p>Each of the contexts being combined should have unique kinds. If more than one context of the same kind is added,  
then only a single context of the duplicated kind will remain.</p>
 
  If <code>new_multi_from</code> is called with a list containing a single context (or a multi-context containing only 1 context),
  then a single-kind context will be returned.</p>

<h3 class="function"><a name="set-3">set/3</a></h3>
<div class="spec">
<p><tt>set(AttributeKey::<a href="#type-attribute_key">attribute_key()</a>, AttributeValue::<a href="#type-attribute_value">attribute_value()</a>, Context::<a href="#type-single_context">single_context()</a>) -&gt; <a href="#type-single_context">single_context()</a></tt><br></p>
<p> </p>
</div><p><p>Set an attribute value with the specified key in a single kind context.</p>
 
  <p>This method cannot be used to set attributes in nested maps.</p>
 
  <p>Any built-in attributes private_attributes, anonymous, key, kind, will be set at the top level of the context.  
Any attributes that are not built-ins will be set in an 'attributes' map.</p>
 
  Attempting to set 'attributes' will result in an attribute named <code>&lt;&lt;"attributes"&gt;&gt;</code>.</p>

<h3 class="function"><a name="set-4">set/4</a></h3>
<div class="spec">
<p><tt>set(ContextKind::<a href="#type-kind_value">kind_value()</a>, AttributeKey::<a href="#type-attribute_key">attribute_key()</a>, AttributeValue::<a href="#type-attribute_value">attribute_value()</a>, Context::<a href="#type-context">context()</a>) -&gt; <a href="#type-multi_context">multi_context()</a></tt><br></p>
<p> </p>
</div><p><p>Set an attribute value in the specified context kind with the specified key.</p>
 
  <p>If the context is a single kind, then it must be of the kind specified.</p>
 
  <p>If it is a multi context, then specified kind must exist in it.</p>
 
  This method cannot be used to set attributes in nested maps.</p>

<h3 class="function"><a name="set_private_attributes-2">set_private_attributes/2</a></h3>
<div class="spec">
<p><tt>set_private_attributes(AttributeValues::[binary()], Context::<a href="#type-single_context">single_context()</a>) -&gt; <a href="#type-single_context">single_context()</a></tt><br></p>
<p> </p>
</div><p><p>Set private attributes for a single kind context.</p>
 
  <p>Designate any number of Context attributes, or properties within them, as private: that is,  
their values will not be sent to LaunchDarkly.</p>
 
  <p>Each parameter can be a simple attribute name, such as "email". Or, if the first character is  
a slash, the parameter is interpreted as a slash-delimited path to a property within a JSON  
object, where the first path component is a Context attribute name and each following  
component is a nested property name: for example, suppose the attribute "address" had the  
following value</p>
 
  <pre>  	#{&lt;&lt;"street"&gt;&gt;: #{&lt;&lt;"line1"&gt;&gt;: &lt;&lt;"abc"&gt;&gt;, &lt;&lt;"line2"&gt;&gt;: &lt;&lt;"def"&gt;&gt;}}</pre>
 
  <p>Using ["/address/street/line1"] in this case would cause the "line1" property to be marked as  
private. This syntax deliberately resembles JSON Pointer, but other JSON Pointer features  
such as array indexing are not supported for Private.</p>
 
  <p>This action only affects analytics events that involve this particular Context. To mark some  
(or all) Context attributes as private for all users, use the overall configuration for the  
SDK.</p>
 
  <p>The attributes "kind" and "key", and the meta attributes (like private_attribute_names) cannot be made private.</p>
 
  <p>In this example, firstName is marked as private, but lastName is not:</p>
 
  <pre>  Context = #{
      kind =&gt; &lt;&lt;"org"&gt;&gt;,
      key =&gt; &lt;&lt;"my-key"&gt;&gt;,
      private_attributes: [&lt;&lt;"firstName"&gt;&gt;],
      attributes =&gt; #{
          &lt;&lt;"firstName"&gt;&gt; =&gt; &lt;&lt;"Pierre"&gt;&gt;,
          &lt;&lt;"lastName"&gt;&gt; =&gt; &lt;&lt;"Menard"&gt;&gt;
      }
  }.</pre>
 
  This is a metadata property, rather than an attribute that can be addressed in evaluations:
  that is, a rule clause that references the attribute name "private_attributes", will not use
  this value, but instead will use whatever value (if any) you have set for that name with a
  method such as set/3 or by including it in the attributes map.</p>

<h3 class="function"><a name="set_private_attributes-3">set_private_attributes/3</a></h3>
<div class="spec">
<p><tt>set_private_attributes(ContextKind::<a href="#type-kind_value">kind_value()</a>, AttributeValues::[binary()], Context::<a href="#type-context">context()</a>) -&gt; <a href="#type-context">context()</a></tt><br></p>
<p> </p>
</div><p><p>Set private attributes for the specified context kind.</p>
 
  Context can either be a single kind context of the specified kind or a multi context containing the kind.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
